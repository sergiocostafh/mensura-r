---
title: Função de Weibull com 3 parâmetros bitruncada para representação da estrutura
  diamétrica de povoamentos florestais
author: Sérgio Costa
date: '2023-05-25'
slug: funcao_de_weibull_com_3_parametros_bitruncada
categories:
  - Biometria
tags: 
  - Distribuição Probabilística
  - Crescimento e Produção
  - Biometria
subtitle: ''
summary: 'Procedimentos para utilização da função de Weibull bitruncada com 3 parâmetros.'
authors: []
lastmod: '2023-06-08T10:12:38-03:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: true
projects: []
---



<div id="contextualização" class="section level2">
<h2>Contextualização</h2>
<p>A estrutura diamétrica, representada pela distribuição do número de árvores por hectare de uma floresta por classes de diâmetro (DAP), traz importantes informações que subsidiam o diagnóstico e/ou as ações de manejo a serem realizadas em um povoamento/comunidade florestal.</p>
<p>A distribuição diamétrica é comumente representada por funções de densidade de probabilidade, sendo a de Weibull uma das mais difundidas para esta finalidade. Esta função possui diferentes variações em sua formulação, podendo apresentar 2 ou 3 parâmetros, e ainda ser truncada à direita, esquerda ou bitruncada.</p>
<p>As variações truncadas são empregadas quando são conhecidos limites superiores e/ou inferiores da distribuição. Neste post empregaremos a função de distribuição probabilística de Weibull bitruncada para representação da estrutura diamétrica de um povoamento florestal que possui os DAPs máximos e mínimos conhecidos ao longo do tempo.</p>
</div>
<div id="modelagem-dos-atributos-do-povoamento" class="section level2">
<h2>Modelagem dos atributos do povoamento</h2>
<p>Para o exemplo deste post, vamos trabalhar com dados de mensurações em quatro parcelas permanentes.
Começamos pela importação dos dados, e pela análise visual dos dados de diâmetro ao longo do tempo.</p>
<pre class="r"><code>library(dplyr)
library(ggplot2)

# importar os dados
dados &lt;- readr::read_csv2(&#39;https://raw.githubusercontent.com/sergiocostafh/open_data/main/cinv_example_proc.csv&#39;)

# ver a estrutura dos dados
glimpse(dados)</code></pre>
<pre><code>## Rows: 32
## Columns: 9
## $ Parcela  &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3…
## $ Idade    &lt;dbl&gt; 6.212183, 8.213552, 9.147159, 12.002738, 13.251198, 14.403833…
## $ DAP      &lt;dbl&gt; 13.67579, 17.25158, 17.98280, 20.90473, 21.15867, 21.60449, 2…
## $ DAPmin   &lt;dbl&gt; 5.50000, 6.10000, 10.30000, 12.73240, 12.73240, 13.05100, 13.…
## $ DAPmax   &lt;dbl&gt; 18.90000, 24.40000, 26.30000, 31.83099, 32.46761, 34.30000, 3…
## $ Hdom     &lt;dbl&gt; 9.514286, 12.942857, 13.942857, 18.200000, 19.971429, 20.9285…
## $ N        &lt;dbl&gt; 1305.3037, 1305.3037, 1277.8236, 1222.9291, 1222.9291, 1222.9…
## $ G        &lt;dbl&gt; 19.70139, 31.49424, 33.42807, 43.49868, 44.66113, 46.80353, 4…
## $ VolTotal &lt;dbl&gt; 90.50862, 180.87759, 204.67636, 341.30509, 386.07986, 433.945…</code></pre>
<pre class="r"><code># calcular o diametro quadratico das parcelas a partir da area basal
dados &lt;- dados %&gt;% 
  mutate(Dg = sqrt((G/N)*40000/pi))

# visualizar as medicoes subsequentes
ggplot(dados)+
  geom_line(aes(x = Idade, y = DAP, color = &#39;DAP médio&#39;))+
  geom_line(aes(x = Idade, y = DAPmin, color = &#39;DAP mínimo&#39;))+
  geom_line(aes(x = Idade, y = DAPmax, color = &#39;DAP máximo&#39;))+
  geom_line(aes(x = Idade, y = Dg, color = &#39;Diâmetro quadrático&#39;))+
  labs(x = &#39;Idade (anos)&#39;,
       y = &#39;Diâmetro (cm)&#39;,
       title = &#39;Crescimento em diâmetro quadrático, DAP médio, mínimo e máximo&#39;,
       subtitle = &#39;Avaliação contínua em 4 parcelas permanentes de Pinus sp.&#39;)+
  scale_color_brewer(palette = &#39;Set1&#39;)+
  facet_wrap(~Parcela)+
  theme_minimal()+
  theme(
    plot.title.position = &#39;plot&#39;,
    legend.title = element_blank(),
        legend.position = &#39;bottom&#39;
    )</code></pre>
<p><img src="{{< blogdown/postref >}}index.pt_files/figure-html/unnamed-chunk-1-1.png" width="672" />
Considerando que estas parcelas são todas pertencentes a um mesmo povoamento, vamos ajustar modelos que descrevem o comportamento médio das variáveis apresentadas no tempo. Usaremos o modelo de Chapman-Richards.</p>
<pre class="r"><code>library(minpack.lm)

# modelo de crescimento em dap
dap_model &lt;- nlsLM(DAP ~ a * (1-exp(-b*Idade))^c,
      data = dados,
      start = list (a = 30, b = .5, c = 1.5))

# modelo de crescimento em dap minimo
dapmin_model &lt;- nlsLM(DAPmin ~ a * (1-exp(-b*Idade))^c,
                   data = dados,
                   start = list (a = 30, b = .5, c = 1.5))

# modelo de crescimento em dap maximo
dapmax_model &lt;- nlsLM(DAPmax ~ a * (1-exp(-b*Idade))^c,
                   data = dados,
                   start = list (a = 30, b = .5, c = 1.5))

# modelo de crescimento em diametro quadratico
dg_model &lt;- nlsLM(Dg ~ a * (1-exp(-b*Idade))^c,
                      data = dados,
                      start = list (a = 30, b = .5, c = 1.5))</code></pre>
<p>Na sequência, vamos analisar visualmente o comportamento dos modelos em relação aos pontos observados.</p>
<pre class="r"><code>library(tidyr)

# criar tabela para predicoes ao longo do tempo
dados_pred &lt;- tibble(Idade = seq(4,17,1)) %&gt;% 
  mutate(DAP = predict(dap_model, .),
         DAPmin = predict(dapmin_model, .),
         DAPmax = predict(dapmax_model, .),
         Dg = predict(dg_model, .)) %&gt;% 
  pivot_longer(DAP:Dg)

# formatar tabela de dados para visualizacao
dados_plot &lt;- dados %&gt;% 
  select(Idade, DAP, DAPmin, DAPmax, Dg) %&gt;% 
  pivot_longer(DAP:Dg)

# visualizar dados observados e estimativas
ggplot(mapping = aes(x = Idade, y = value, color = name))+
  geom_point(data = dados_plot)+
  geom_line(data = dados_pred)+
  labs(x = &#39;Idade (anos)&#39;,
       y = &#39;Diâmetro (cm)&#39;,
       title = &#39;Crescimento em diâmetro quadrático, DAP médio, mínimo e máximo&#39;,
       subtitle = &#39;Avaliação contínua em 4 parcelas permanentes de Pinus sp.&#39;)+
  scale_color_brewer(palette = &#39;Set1&#39;)+
  scale_x_continuous(limits = c(0,20))+
  theme_minimal()+
  theme(
    plot.title.position = &#39;plot&#39;,
    legend.title = element_blank(),
    legend.position = &#39;bottom&#39;
  )</code></pre>
<p><img src="{{< blogdown/postref >}}index.pt_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<p>Constata-se que os modelos apresentam o comportamento adequado para representar os diferentes tipos de diâmetros que queremos modelar. Poderíamos testar outros modelos e indicadores de qualidade de ajuste para escolher a melhor equação, mas não é o nosso objetivo agora.<br />
Agora que já podemos obter os diâmetros quadrático, médio, mínimo e máximo em qualquer momento no tempo, seguiremos para a etapa de obtenção da estrutura diamétrica.</p>
</div>
<div id="função-bitruncada-de-weibull-com-3-parâmetros" class="section level2">
<h2>Função bitruncada de Weibull com 3 parâmetros</h2>
<p>Primeiro, vamos às formulações. A função bitruncada de densidade de probabilidade de Weibull com 3 parâmetros é expressa matematicamente da seguinte maneira:</p>
<p><span class="math display">\[\frac{\frac{c}{b}\left(\frac{x-a}{b}\right)^{c-1}exp\left[\left(\frac{t-a}{b}\right)^c-\left(\frac{x-a}{b}\right)^c\right]}{1-exp\left[-\left(\frac{T-a}{b}\right)^c\right]}\]</span></p>
<p>Em que:<br />
<em>a: parâmetro de locação;<br />
</em>b: parâmetro de escala;<br />
<em>c: parâmetro de forma;<br />
</em>x: variável aleatória (DAP ou classe de DAP);<br />
<em>T: ponto de truncamento à direita (DAP máximo);<br />
</em>t: ponto de truncamento à esquerda (DAP mínimo).</p>
<p>Obteremos os parâmetros <code>a</code>, <code>b</code>, e <code>c</code> da função pelo método dos momentos não centrais, conforme o estudo de <a href="https://www.scielo.br/j/cflo/a/zM9dPMdWZ7LhrQJyz6M6PyJ/?format=pdf&amp;lang=pt">Arce (2004)</a>. Para tal, as seguintes expressões devem ser usadas.</p>
<p>Parâmetro <code>a</code>:<br />
<span class="math display">\[a=\frac{\overline{d}-\left(dg-D_{min}\right)}{1-\frac{1}{n^{\left(1+\frac{1}{c}\right)}}}\]</span>
Parâmetro <code>b</code>:<br />
<span class="math display">\[b=\left[\frac{\overline{d}-d_{min}}{\Gamma\left(1+\frac{1}{c}\right)}\right]\left[1-\frac{1}{n^{\left(1+\frac{1}{c}\right)}}\right]\]</span><br />
Parâmetro <code>c</code>:<br />
<span class="math display">\[dg^2=\overline{d}^2+\left(\overline{d}-d_{min}\right)^2\left[\frac{\frac{\Gamma(1+\frac{2}{c})}{\Gamma(1+\frac{1}{c})^2}-1}{\left[1-\frac{1}{n}^{\left(1+\frac{1}{c}\right)}\right]^2}\right]\]</span>
O parâmetro <code>c</code> pode ser obtida por um técnica iterativa, desde que conhecidos os valores para as demais variáveis da função. A partir do parâmetro <code>c</code>, podem ser obtidos os valores de <code>a</code> e <code>b</code> por substituição nas respectivas fórmulas.</p>
<p>Agora vamos aplicar o que foi descrito. Começamos pela implementação das fórmulas.</p>
<pre class="r"><code># funcao para obtencao do parametro a
a_function &lt;- function(dap, dg, dapmin, c, n){(dap-(dg-dapmin))/(1-(1/n^(1+1/c)))}

# funcao para obtencao do parametro b
b_function &lt;- function(dap, dapmin, c, n){((dap-dapmin)/gamma(1+1/c))*(1-1/(n^1+1/c))}

# funcao para obtencao do parametro c
c_function &lt;- function (dap, dg, dapmin, c, n){
  ((dap^2+(dap-dapmin)^2*((gamma(1+2/c)/(gamma(1+1/c)^2)-1)/(1-(1/n)^(1+1/c))^2))-dg^2)^2
}

# funcao bitruncada de Weibull com 3 paramentros
weibull3p_bitr &lt;- function(x, a, b, c, dapmin, dapmax){
  ((c/b)*(((x-a)/b)^(c-1))*
     exp((((dapmin-a)/b)^c)-(((x-a)/b)^c)))/
    (1-exp(-((dapmax-a)/b)^c))
}</code></pre>
<p>Na sequência iremos aplicar as funções que declaramos acima para obtenção dos parâmetros <code>a</code>, <code>b</code> e <code>c</code> da função de Weibull. Podemos utilizar a função <code>optimize</code> para obter o parâmetro <code>c</code>. Observe que declaramos a equação de um modo que <code>c</code> é o valor que zero o resultado da equação. Da maneira a qual iremos declarar, <code>c</code> deverá um valor entre 0 e 100 que minimiza (de preferência, zere) o resultado da função <code>c_function</code>.<br />
O aninhamento da base de dados (função <code>nest</code>) por idade em conjunto com a função <code>map</code> do pacote <code>purrr</code>, nos fornecem a estrutura necessária para obter o parâmetro <code>c</code> pra cada linha (idade) da base de dados.<br />
Um dos parâmetros necessários para calcularmos o número de árvores por classe diamétrica, é o próprio número de árvores total do povoamento. Como aqui não trabalharemos com um modelo de sobrevivência, vamos assumir 1000 árvores por hectare em todas as idades, apenas para fins de exemplo.</p>
<pre class="r"><code>library(purrr)

# numero de arvores por hectare
narv &lt;- 1000

# aplicar as funcoes na tabela de predicoes para obtencao dos parametros a, b, e c
dados_pred &lt;- dados_pred %&gt;% 
  group_by(Idade) %&gt;%
  pivot_wider(names_from = name, values_from = value) %&gt;% 
  nest() %&gt;% 
  mutate(
    c = map(.x = data, 
            ~optimize(
              c_function,
              lower = 0, upper = 100, 
              tol = .001,
              dap = .x$DAP,
              dg = .x$Dg,
              dapmin = .x$DAPmin,
              n = narv
            )$minimum)
  ) %&gt;% 
  unnest(c(data, c)) %&gt;% 
  mutate(
    a = a_function(DAP,Dg,DAPmin,c,narv),
    b = b_function(DAP,DAPmin,c,narv)
  )

# visualizar as primeiras linhas da base de dados
head(dados_pred)</code></pre>
<pre><code>## # A tibble: 6 × 8
## # Groups:   Idade [6]
##   Idade   DAP DAPmin DAPmax    Dg     c     a     b
##   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     4  10.2   3.67   13.3  10.4  3.84  3.49  7.21
## 2     5  13.1   5.03   17.4  13.3  3.67  4.80  8.94
## 3     6  15.6   6.36   21.0  15.9  3.51  6.09 10.3 
## 4     7  17.8   7.63   24.1  18.1  3.35  7.32 11.3 
## 5     8  19.5   8.81   26.8  19.8  3.21  8.47 11.9 
## 6     9  20.9   9.88   29.0  21.3  3.08  9.52 12.3</code></pre>
<p>Agora que temos os parâmetros da função de Weibull do povoamento em diferentes momentos no tempo, podemos construir a distribuição diamétrica média de cada idade aplicando a função bitruncada de Weibull com três parâmetros.</p>
<pre class="r"><code># criar classes de dap
classes_dap &lt;- 1:50

# criar base de dados para construcao da estrutura diametrica em cada idade
dist_diam_pred &lt;- dados_pred %&gt;% 
  group_by(Idade) %&gt;% 
  nest() %&gt;% 
  mutate(
    dist = map(.x = data, ~weibull3p_bitr(classes_dap, .x$a, .x$b, .x$c, .x$DAPmin, .x$DAPmax) * narv)
  ) %&gt;% 
  unnest(c(data, dist)) %&gt;% 
  mutate(cdap = classes_dap) 

# visualizar estrutura diametrica ao longo do tempo
ggplot(dist_diam_pred)+
  geom_line(aes(x = cdap, y = dist, group = Idade, color = Idade))+
  labs(x = &#39;DAP (cm)&#39;,
       y = &#39;Frequência (n/ha)&#39;,
       title = &#39;Distribuição diamétrica de um povoamento de Pinus sp. dos 4 aos 17 anos de idade&#39;)+
  scale_color_viridis_c(name = &#39;Idade (anos)&#39;)+
  theme_minimal()+
  theme(
    plot.title.position = &#39;plot&#39;,
    legend.position = &#39;right&#39;
  )</code></pre>
<p><img src="{{< blogdown/postref >}}index.pt_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>O gráfico apresentado demonstra a flexibilidade da função de Weibull para representar a estrutura diamétrica de povoamentos florestais equiâneos em qualquer momento no tempo. Uma abordagem mais aprimorada envolve a aplicação de um modelo de sobrevivência para estimativa do número de árvores esperada em cada idade, a partir de uma densidade inicial.</p>
<style>
body {
text-align: justify}
h1 {
text-align: center}
</style>
<style type="text/css">

body, td {
   font-size: 14px;
}
code.r{
  font-size: 14px;
}
pre {
  font-size: 14px
}
</style>
</div>
